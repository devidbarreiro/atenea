name: Deploy to Server

# Se ejecuta autom√°ticamente cuando:
# - Push a dev ‚Üí despliega a DEV
# - Push a demo ‚Üí despliega a DEMO
# - Push a main ‚Üí despliega a PROD
on:
  push:
    branches: [ dev, demo, main ]

jobs:
  test:
    runs-on: ubuntu-latest
    name: Run Tests
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'
    
    - name: Install system dependencies for Manim
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          pkg-config \
          python3-dev \
          ffmpeg \
          libcairo2-dev \
          libpango1.0-dev \
          libpangocairo-1.0-0 \
          libgirepository1.0-dev \
          gir1.2-pango-1.0
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        
    - name: Run tests
      env:
        SECRET_KEY: ${{ secrets.SECRET_KEY_CI || 'test-secret-key-for-ci' }}
        USE_SQLITE: 'True'
        DEBUG: 'False'
        ALLOWED_HOSTS: 'localhost,127.0.1'
        GCS_BUCKET_NAME: 'test-bucket'
        GCS_PROJECT_ID: 'test-project'
        GOOGLE_APPLICATION_CREDENTIALS: '/tmp/fake-credentials.json'
        HEYGEN_API_KEY: 'test-key'
        GEMINI_API_KEY: 'test-key'
      run: |
        python manage.py test

  deploy:
    needs: test
    runs-on: ubuntu-latest
    name: Deploy to Server
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Determine environment
      id: env
      run: |
        BRANCH="${{ github.ref_name }}"
        if [ "$BRANCH" == "dev" ]; then
          echo "env=dev" >> $GITHUB_OUTPUT
        elif [ "$BRANCH" == "demo" ]; then
          echo "env=demo" >> $GITHUB_OUTPUT
        elif [ "$BRANCH" == "main" ]; then
          echo "env=prod" >> $GITHUB_OUTPUT
        else
          echo "‚ùå Branch desconocido: $BRANCH"
          exit 1
        fi
        echo "‚úÖ Desplegando a: ${{ steps.env.outputs.env }}"
    
    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        # Guardar la clave SSH preservando saltos de l√≠nea correctamente
        # Usar printf para preservar saltos de l√≠nea y caracteres especiales
        printf '%s\n' "${{ secrets.SSH_KEY }}" > ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key
        # Verificar que la clave es v√°lida
        if ! ssh-keygen -l -f ~/.ssh/deploy_key > /dev/null 2>&1; then
          echo "‚ùå Error: La clave SSH no es v√°lida"
          echo "Primeras l√≠neas de la clave:"
          head -3 ~/.ssh/deploy_key
          exit 1
        fi
        echo "‚úÖ Clave SSH v√°lida"
        ssh-keyscan -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true
        chmod 644 ~/.ssh/known_hosts
    
    - name: Prepare deployment files
      run: |
        echo "üìã Verificando docker-compose para ${{ steps.env.outputs.env }}"
        if [ ! -f "docker/docker-compose.${{ steps.env.outputs.env }}.yml" ]; then
          echo "‚ùå Error: No se encontr√≥ docker-compose.${{ steps.env.outputs.env }}.yml"
          exit 1
        fi
        echo "‚úÖ Archivos listos para despliegue"
    
    - name: Deploy to ${{ steps.env.outputs.env }}
      env:
        SSH_KEY: ~/.ssh/deploy_key
        SSH_HOST: ${{ secrets.SSH_HOST }}
        SSH_USER: ${{ secrets.SSH_USERNAME }}
        ENV: ${{ steps.env.outputs.env }}
      run: |
        # ENV_DIR se construye en el servidor, no en el runner
        ENV_DIR_REMOTE="~/$ENV"
        echo "üìÅ Preparando directorio $ENV_DIR_REMOTE en el servidor"
        
        # Crear directorio en el servidor
        ssh -i $SSH_KEY -o StrictHostKeyChecking=no $SSH_USER@$SSH_HOST \
          "mkdir -p $ENV_DIR_REMOTE/html $ENV_DIR_REMOTE/backups" || true
        
        # Preservar credentials.json si existe antes del deploy
        echo "üîê Preservando credentials.json si existe..."
        ssh -i $SSH_KEY -o StrictHostKeyChecking=no $SSH_USER@$SSH_HOST \
          "if [ -f '$ENV_DIR_REMOTE/html/credentials.json' ]; then
            echo 'üìã Guardando credentials.json temporalmente...'
            cp '$ENV_DIR_REMOTE/html/credentials.json' '$ENV_DIR_REMOTE/html/credentials.json.backup' || true
          fi"
        
        # Copiar c√≥digo al servidor usando rsync (excluyendo .git y otros archivos innecesarios)
        echo "üì§ Copiando c√≥digo al servidor..."
        rsync -avz --delete --no-ACL --no-xattrs \
          -e "ssh -i $SSH_KEY -o StrictHostKeyChecking=no" \
          --exclude='.git' \
          --exclude='**/__pycache__/' \
          --exclude='**/__pycache__/**' \
          --exclude='*.pyc' \
          --exclude='*.pyo' \
          --exclude='.env' \
          --exclude='credentials.json' \
          --exclude='venv' \
          --exclude='**/venv/**' \
          --exclude='db.sqlite3' \
          --exclude='.pytest_cache' \
          --exclude='**/.pytest_cache/**' \
          --exclude='node_modules' \
          --exclude='**/node_modules/**' \
          --exclude='.DS_Store' \
          --exclude='**/.DS_Store' \
          --exclude='*.swp' \
          --exclude='*.swo' \
          --exclude='*~' \
          ./ $SSH_USER@$SSH_HOST:$ENV_DIR_REMOTE/html/ || {
          echo "‚ö†Ô∏è  Advertencia: rsync complet√≥ con algunos errores menores"
          echo "üí° Esto puede ser normal si hay archivos temporales o con atributos extendidos"
        }
        
        # Restaurar credentials.json si exist√≠a antes
        echo "üîê Restaurando credentials.json si exist√≠a..."
        ssh -i $SSH_KEY -o StrictHostKeyChecking=no $SSH_USER@$SSH_HOST \
          "if [ -f '$ENV_DIR_REMOTE/html/credentials.json.backup' ]; then
            mv '$ENV_DIR_REMOTE/html/credentials.json.backup' '$ENV_DIR_REMOTE/html/credentials.json'
            echo '‚úÖ credentials.json restaurado'
          else
            echo \"‚ö†Ô∏è  credentials.json no exist√≠a antes, debe crearse manualmente en $ENV_DIR_REMOTE/html/credentials.json\"
          fi"
        
        # Copiar docker-compose al servidor (dentro de html/)
        echo "üìã Copiando docker-compose.yml a html/"
        scp -i $SSH_KEY -o StrictHostKeyChecking=no \
          docker/docker-compose.$ENV.yml \
          $SSH_USER@$SSH_HOST:$ENV_DIR_REMOTE/html/docker-compose.yml
        
        # Ejecutar despliegue en el servidor
        echo "üöÄ Ejecutando despliegue en el servidor"
        ssh -i $SSH_KEY -o StrictHostKeyChecking=no $SSH_USER@$SSH_HOST \
          ENV="$ENV" bash -s << 'DEPLOY_SCRIPT'
        set -e
        ENV_DIR="$HOME/$ENV"
        echo "üìÇ Cambiando a directorio: $ENV_DIR/html"
        cd $ENV_DIR/html || { echo "‚ùå Error: No se encuentra $ENV_DIR/html"; exit 1; }
        
        # Verificar que existe .env
        if [ ! -f ".env" ]; then
          echo "‚ö†Ô∏è  Advertencia: No se encuentra .env en $ENV_DIR/html/.env"
          echo "üí° El archivo .env debe existir en el servidor antes de ejecutar docker compose"
          echo "üí° Puedes crearlo manualmente o copiarlo desde $ENV_DIR/.env si existe"
          if [ -f "$ENV_DIR/.env" ]; then
            echo "üìã Copiando .env desde $ENV_DIR/.env a $ENV_DIR/html/.env"
            cp "$ENV_DIR/.env" "$ENV_DIR/html/.env"
          else
            echo "‚ùå Error: No se encuentra .env en $ENV_DIR/.env ni en $ENV_DIR/html/.env"
            echo "‚ùå El despliegue no puede continuar sin el archivo .env"
            exit 1
          fi
        else
          echo "‚úÖ Archivo .env encontrado en $ENV_DIR/html/.env"
        fi
        
        # Verificar que existe credentials.json (cr√≠tico para GCS)
        if [ ! -f "credentials.json" ]; then
          echo "‚ö†Ô∏è  Advertencia: No se encuentra credentials.json en $ENV_DIR/html/credentials.json"
          echo "üí° El archivo credentials.json debe existir en el servidor para que GCS funcione"
          echo "üí° Puedes crearlo manualmente o copiarlo desde $ENV_DIR/credentials.json si existe"
          if [ -f "$ENV_DIR/credentials.json" ]; then
            echo "üìã Copiando credentials.json desde $ENV_DIR/credentials.json a $ENV_DIR/html/credentials.json"
            cp "$ENV_DIR/credentials.json" "$ENV_DIR/html/credentials.json"
            echo "‚úÖ credentials.json copiado desde $ENV_DIR/"
          else
            echo "‚ùå Error: No se encuentra credentials.json en $ENV_DIR/credentials.json ni en $ENV_DIR/html/credentials.json"
            echo "‚ùå El despliegue puede continuar pero GCS no funcionar√° sin credentials.json"
            echo "üí° Crea el archivo manualmente en $ENV_DIR/html/credentials.json antes de usar GCS"
          fi
        else
          echo "‚úÖ Archivo credentials.json encontrado en $ENV_DIR/html/credentials.json"
        fi
        
        # Verificar que POSTGRES_PASSWORD est√° definido en .env
        echo "üîç Verificando variables cr√≠ticas en .env..."
        if grep -q "^POSTGRES_PASSWORD=" .env 2>/dev/null; then
          echo "‚úÖ POSTGRES_PASSWORD encontrado en .env"
        else
          echo "‚ö†Ô∏è  POSTGRES_PASSWORD no est√° definido en .env"
          echo "üîë Generando contrase√±a autom√°ticamente..."
          # Generar contrase√±a segura (25 caracteres alfanum√©ricos)
          POSTGRES_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-25)
          echo "" >> .env
          echo "# PostgreSQL password (generado autom√°ticamente)" >> .env
          echo "POSTGRES_PASSWORD=$POSTGRES_PASSWORD" >> .env
          echo "‚úÖ POSTGRES_PASSWORD generado y agregado al .env"
          echo "‚ö†Ô∏è  IMPORTANTE: Guarda esta contrase√±a en un lugar seguro"
          echo "üîë POSTGRES_PASSWORD=$POSTGRES_PASSWORD"
          echo "üí° Si ya existe una base de datos con otra contrase√±a, actualiza manualmente el .env"
        fi
        
        # Mostrar informaci√≥n del .env (sin mostrar valores sensibles)
        echo "üìã Variables definidas en .env (primeras 10):"
        grep -E "^[A-Z_]+=" .env | sed 's/=.*/=***/' | head -10 || echo "‚ö†Ô∏è  No se pudieron leer las variables del .env"
        
        echo "üõë Deteniendo y eliminando contenedores existentes"
        
        # M√âTODO DIRECTO: Eliminar contenedores por nombre exacto primero
        echo "üóëÔ∏è  Eliminando contenedores por nombre exacto..."
        docker rm -f html-web-1 html-db-1 html-redis-1 html-celery_worker-1 html-celery_beat-1 html-migrate-1 html-collectstatic-1 2>/dev/null || true
        docker rm -f ${ENV}-web-1 ${ENV}-db-1 ${ENV}-redis-1 ${ENV}-celery_worker-1 ${ENV}-celery_beat-1 ${ENV}-migrate-1 ${ENV}-collectstatic-1 2>/dev/null || true
        
        # Eliminar con docker compose
        echo "üóëÔ∏è  docker compose down..."
        docker compose down --remove-orphans -v 2>/dev/null || true
        docker compose rm -f 2>/dev/null || true
        
        # Buscar y eliminar TODOS los contenedores con prefijo html- o ${ENV}-
        echo "üîç Buscando contenedores hu√©rfanos..."
        for container_id in $(docker ps -aq --filter "name=html-" 2>/dev/null); do
          echo "üóëÔ∏è  Eliminando contenedor: $container_id"
          docker rm -f "$container_id" 2>/dev/null || true
        done
        for container_id in $(docker ps -aq --filter "name=${ENV}-" 2>/dev/null); do
          echo "üóëÔ∏è  Eliminando contenedor: $container_id"
          docker rm -f "$container_id" 2>/dev/null || true
        done
        
        # Verificaci√≥n y limpieza forzada
        REMAINING=$(docker ps -a --format "{{.Names}}" 2>/dev/null | grep -E "^(html-|${ENV}-)" || echo "")
        if [ ! -z "$REMAINING" ]; then
          echo "‚ö†Ô∏è  Contenedores restantes: $REMAINING"
          echo "üîÑ Forzando eliminaci√≥n..."
          for name in $REMAINING; do
            docker rm -f "$name" 2>/dev/null || true
          done
        fi
        
        # Limpiar redes hu√©rfanas
        echo "üßπ Limpiando redes y vol√∫menes hu√©rfanos..."
        docker network prune -f 2>/dev/null || true
        
        # Verificaci√≥n final
        sleep 2
        FINAL=$(docker ps -a --format "{{.Names}}" 2>/dev/null | grep -E "^(html-|${ENV}-)" || echo "")
        if [ ! -z "$FINAL" ]; then
          echo "‚ùå ERROR: A√∫n existen contenedores: $FINAL"
          echo "üîÑ √öltimo intento..."
          for name in $FINAL; do
            docker kill "$name" 2>/dev/null || true
            docker rm -f "$name" 2>/dev/null || true
          done
        else
          echo "‚úÖ Todos los contenedores eliminados"
        fi
        echo "üî® Construyendo y reiniciando contenedores"
        docker compose build --no-cache
        docker compose up -d
        
        echo "‚è≥ Esperando a que los servicios est√©n listos..."
        sleep 15
        
        # Verificar que la base de datos est√© lista
        echo "üîç Verificando conexi√≥n a la base de datos..."
        MAX_RETRIES=30
        RETRY_COUNT=0
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          if docker compose exec -T db pg_isready -U ${POSTGRES_USER:-atenea} > /dev/null 2>&1; then
            echo "‚úÖ Base de datos lista"
            break
          fi
          RETRY_COUNT=$((RETRY_COUNT + 1))
          echo "‚è≥ Esperando base de datos... ($RETRY_COUNT/$MAX_RETRIES)"
          sleep 2
        done
        
        if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
          echo "‚ùå Error: La base de datos no est√° lista despu√©s de $MAX_RETRIES intentos"
          exit 1
        fi
        
        # Esperar un poco m√°s para asegurar que la base de datos est√© completamente lista
        sleep 5
        
        echo "üîÑ Ejecutando migraciones"
        echo "üìã Verificando estado de migraciones antes de ejecutar..."
        docker compose exec -T web python manage.py showmigrations --list 2>&1 | head -30 || true
        
        echo "üöÄ Ejecutando migraciones..."
        MIGRATE_OUTPUT=$(docker compose --profile tools run --rm migrate 2>&1)
        MIGRATE_EXIT_CODE=$?
        
        if [ $MIGRATE_EXIT_CODE -ne 0 ]; then
          echo "‚ùå Error: Las migraciones fallaron (c√≥digo de salida: $MIGRATE_EXIT_CODE)"
          echo "üìã Salida completa de migraciones:"
          echo "$MIGRATE_OUTPUT"
          echo "üìã Verificando estado de migraciones despu√©s del error..."
          docker compose exec -T web python manage.py showmigrations --list 2>&1 | head -30 || true
          exit 1
        fi
        
        echo "$MIGRATE_OUTPUT"
        echo "‚úÖ Migraciones ejecutadas correctamente"
        echo "üìã Verificando estado final de migraciones..."
        docker compose exec -T web python manage.py showmigrations --list 2>&1 | grep -E "(\[ \]|\[X\])" | tail -20 || true
        
        echo "üì¶ Recolectando archivos est√°ticos"
        if ! docker compose --profile tools run --rm collectstatic; then
          echo "‚ùå Error: collectstatic fall√≥"
          exit 1
        fi
        echo "‚úÖ Despliegue a $ENV completado!"
        if [ "$ENV" == "prod" ]; then
          echo "üåê URL: https://atenea.nxhumans.com"
        else
          echo "üåê URL: https://$ENV.atenea.nxhumans.com"
        fi
        DEPLOY_SCRIPT
