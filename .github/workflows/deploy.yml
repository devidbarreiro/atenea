name: Deploy to Server

# Se ejecuta autom√°ticamente cuando:
# - Push a dev ‚Üí despliega a DEV
# - Push a demo ‚Üí despliega a DEMO
# - Push a main ‚Üí despliega a PROD
on:
  push:
    branches: [ dev, demo, main ]

jobs:
  test:
    runs-on: ubuntu-latest
    name: Run Tests
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'
    
    - name: Install system dependencies for Manim
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          pkg-config \
          python3-dev \
          ffmpeg \
          libcairo2-dev \
          libpango1.0-dev \
          libpangocairo-1.0-0 \
          libgirepository1.0-dev \
          gir1.2-pango-1.0
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        
    - name: Run tests
      env:
        SECRET_KEY: ${{ secrets.SECRET_KEY_CI || 'test-secret-key-for-ci' }}
        USE_SQLITE: 'True'
        DEBUG: 'False'
        ALLOWED_HOSTS: 'localhost,127.0.1'
        GCS_BUCKET_NAME: 'test-bucket'
        GCS_PROJECT_ID: 'test-project'
        GOOGLE_APPLICATION_CREDENTIALS: '/tmp/fake-credentials.json'
        HEYGEN_API_KEY: 'test-key'
        GEMINI_API_KEY: 'test-key'
      run: |
        python manage.py test

  deploy:
    needs: test
    runs-on: ubuntu-latest
    name: Deploy to Server
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Determine environment
      id: env
      run: |
        BRANCH="${{ github.ref_name }}"
        if [ "$BRANCH" == "dev" ]; then
          echo "env=dev" >> $GITHUB_OUTPUT
        elif [ "$BRANCH" == "demo" ]; then
          echo "env=demo" >> $GITHUB_OUTPUT
        elif [ "$BRANCH" == "main" ]; then
          echo "env=prod" >> $GITHUB_OUTPUT
        else
          echo "‚ùå Branch desconocido: $BRANCH"
          exit 1
        fi
        echo "‚úÖ Desplegando a: ${{ steps.env.outputs.env }}"
    
    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        # Guardar la clave SSH preservando saltos de l√≠nea correctamente
        # Usar printf para preservar saltos de l√≠nea y caracteres especiales
        printf '%s\n' "${{ secrets.SSH_KEY }}" > ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key
        # Verificar que la clave es v√°lida
        if ! ssh-keygen -l -f ~/.ssh/deploy_key > /dev/null 2>&1; then
          echo "‚ùå Error: La clave SSH no es v√°lida"
          echo "Primeras l√≠neas de la clave:"
          head -3 ~/.ssh/deploy_key
          exit 1
        fi
        echo "‚úÖ Clave SSH v√°lida"
        ssh-keyscan -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true
        chmod 644 ~/.ssh/known_hosts
    
    - name: Prepare deployment files
      run: |
        echo "üìã Verificando docker-compose para ${{ steps.env.outputs.env }}"
        if [ ! -f "docker/docker-compose.${{ steps.env.outputs.env }}.yml" ]; then
          echo "‚ùå Error: No se encontr√≥ docker-compose.${{ steps.env.outputs.env }}.yml"
          exit 1
        fi
        echo "‚úÖ Archivos listos para despliegue"
    
    - name: Deploy to ${{ steps.env.outputs.env }}
      env:
        SSH_KEY: ~/.ssh/deploy_key
        SSH_HOST: ${{ secrets.SSH_HOST }}
        SSH_USER: ${{ secrets.SSH_USERNAME }}
        ENV: ${{ steps.env.outputs.env }}
      run: |
        # ENV_DIR se construye en el servidor, no en el runner
        ENV_DIR_REMOTE="~/$ENV"
        echo "üìÅ Preparando directorio $ENV_DIR_REMOTE en el servidor"
        
        # Crear directorio en el servidor
        ssh -i $SSH_KEY -o StrictHostKeyChecking=no $SSH_USER@$SSH_HOST \
          "mkdir -p $ENV_DIR_REMOTE/html $ENV_DIR_REMOTE/backups" || true
        
        # Preservar credentials.json si existe antes del deploy
        echo "üîê Preservando credentials.json si existe..."
        ssh -i $SSH_KEY -o StrictHostKeyChecking=no $SSH_USER@$SSH_HOST \
          "if [ -f '$ENV_DIR_REMOTE/html/credentials.json' ]; then
            echo 'üìã Guardando credentials.json temporalmente...'
            cp '$ENV_DIR_REMOTE/html/credentials.json' '$ENV_DIR_REMOTE/html/credentials.json.backup' || true
          fi"
        
        # Copiar c√≥digo al servidor usando rsync (excluyendo .git y otros archivos innecesarios)
        echo "üì§ Copiando c√≥digo al servidor..."
        rsync -avz --delete \
          -e "ssh -i $SSH_KEY -o StrictHostKeyChecking=no" \
          --exclude='.git' \
          --exclude='__pycache__' \
          --exclude='*.pyc' \
          --exclude='.env' \
          --exclude='credentials.json' \
          --exclude='venv' \
          --exclude='db.sqlite3' \
          --exclude='.pytest_cache' \
          --exclude='node_modules' \
          ./ $SSH_USER@$SSH_HOST:$ENV_DIR_REMOTE/html/
        
        # Restaurar credentials.json si exist√≠a antes
        echo "üîê Restaurando credentials.json si exist√≠a..."
        ssh -i $SSH_KEY -o StrictHostKeyChecking=no $SSH_USER@$SSH_HOST \
          "if [ -f '$ENV_DIR_REMOTE/html/credentials.json.backup' ]; then
            mv '$ENV_DIR_REMOTE/html/credentials.json.backup' '$ENV_DIR_REMOTE/html/credentials.json'
            echo '‚úÖ credentials.json restaurado'
          else
            echo \"‚ö†Ô∏è  credentials.json no exist√≠a antes, debe crearse manualmente en $ENV_DIR_REMOTE/html/credentials.json\"
          fi"
        
        # Copiar docker-compose al servidor (dentro de html/)
        echo "üìã Copiando docker-compose.yml a html/"
        scp -i $SSH_KEY -o StrictHostKeyChecking=no \
          docker/docker-compose.$ENV.yml \
          $SSH_USER@$SSH_HOST:$ENV_DIR_REMOTE/html/docker-compose.yml
        
        # Ejecutar despliegue en el servidor
        echo "üöÄ Ejecutando despliegue en el servidor"
        ssh -i $SSH_KEY -o StrictHostKeyChecking=no $SSH_USER@$SSH_HOST \
          ENV="$ENV" bash -s << 'DEPLOY_SCRIPT'
        set -e
        ENV_DIR="$HOME/$ENV"
        echo "üìÇ Cambiando a directorio: $ENV_DIR/html"
        cd $ENV_DIR/html || { echo "‚ùå Error: No se encuentra $ENV_DIR/html"; exit 1; }
        
        # Verificar que existe .env
        if [ ! -f ".env" ]; then
          echo "‚ö†Ô∏è  Advertencia: No se encuentra .env en $ENV_DIR/html/.env"
          echo "üí° El archivo .env debe existir en el servidor antes de ejecutar docker compose"
          echo "üí° Puedes crearlo manualmente o copiarlo desde $ENV_DIR/.env si existe"
          if [ -f "$ENV_DIR/.env" ]; then
            echo "üìã Copiando .env desde $ENV_DIR/.env a $ENV_DIR/html/.env"
            cp "$ENV_DIR/.env" "$ENV_DIR/html/.env"
          else
            echo "‚ùå Error: No se encuentra .env en $ENV_DIR/.env ni en $ENV_DIR/html/.env"
            echo "‚ùå El despliegue no puede continuar sin el archivo .env"
            exit 1
          fi
        else
          echo "‚úÖ Archivo .env encontrado en $ENV_DIR/html/.env"
        fi
        
        # Verificar que existe credentials.json (cr√≠tico para GCS)
        if [ ! -f "credentials.json" ]; then
          echo "‚ö†Ô∏è  Advertencia: No se encuentra credentials.json en $ENV_DIR/html/credentials.json"
          echo "üí° El archivo credentials.json debe existir en el servidor para que GCS funcione"
          echo "üí° Puedes crearlo manualmente o copiarlo desde $ENV_DIR/credentials.json si existe"
          if [ -f "$ENV_DIR/credentials.json" ]; then
            echo "üìã Copiando credentials.json desde $ENV_DIR/credentials.json a $ENV_DIR/html/credentials.json"
            cp "$ENV_DIR/credentials.json" "$ENV_DIR/html/credentials.json"
            echo "‚úÖ credentials.json copiado desde $ENV_DIR/"
          else
            echo "‚ùå Error: No se encuentra credentials.json en $ENV_DIR/credentials.json ni en $ENV_DIR/html/credentials.json"
            echo "‚ùå El despliegue puede continuar pero GCS no funcionar√° sin credentials.json"
            echo "üí° Crea el archivo manualmente en $ENV_DIR/html/credentials.json antes de usar GCS"
          fi
        else
          echo "‚úÖ Archivo credentials.json encontrado en $ENV_DIR/html/credentials.json"
        fi
        
        # Verificar que POSTGRES_PASSWORD est√° definido en .env
        echo "üîç Verificando variables cr√≠ticas en .env..."
        if grep -q "^POSTGRES_PASSWORD=" .env 2>/dev/null; then
          echo "‚úÖ POSTGRES_PASSWORD encontrado en .env"
        else
          echo "‚ö†Ô∏è  POSTGRES_PASSWORD no est√° definido en .env"
          echo "üîë Generando contrase√±a autom√°ticamente..."
          # Generar contrase√±a segura (25 caracteres alfanum√©ricos)
          POSTGRES_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-25)
          echo "" >> .env
          echo "# PostgreSQL password (generado autom√°ticamente)" >> .env
          echo "POSTGRES_PASSWORD=$POSTGRES_PASSWORD" >> .env
          echo "‚úÖ POSTGRES_PASSWORD generado y agregado al .env"
          echo "‚ö†Ô∏è  IMPORTANTE: Guarda esta contrase√±a en un lugar seguro"
          echo "üîë POSTGRES_PASSWORD=$POSTGRES_PASSWORD"
          echo "üí° Si ya existe una base de datos con otra contrase√±a, actualiza manualmente el .env"
        fi
        
        # Mostrar informaci√≥n del .env (sin mostrar valores sensibles)
        echo "üìã Variables definidas en .env (primeras 10):"
        grep -E "^[A-Z_]+=" .env | sed 's/=.*/=***/' | head -10 || echo "‚ö†Ô∏è  No se pudieron leer las variables del .env"
        
        echo "üõë Deteniendo y eliminando contenedores existentes"
        
        # Primero, detener todos los contenedores que puedan estar corriendo
        echo "‚è∏Ô∏è  Deteniendo contenedores..."
        docker compose stop || true
        
        # Detener contenedores espec√≠ficos por nombre (por si acaso)
        docker stop html-web-1 html-db-1 html-redis-1 html-celery_worker-1 html-celery_beat-1 2>/dev/null || true
        docker stop ${ENV}-web-1 ${ENV}-db-1 ${ENV}-redis-1 ${ENV}-celery_worker-1 ${ENV}-celery_beat-1 2>/dev/null || true
        
        # Esperar un momento para que los contenedores se detengan completamente
        sleep 3
        
        # Eliminar contenedores con docker compose down
        echo "üóëÔ∏è  Eliminando contenedores con docker compose down..."
        docker compose down --remove-orphans -v || true
        
        # Eliminar contenedores que puedan estar detenidos pero a√∫n existan
        docker compose rm -f || true
        
        # Lista de contenedores comunes que pueden existir (incluyendo variaciones)
        COMMON_CONTAINERS=(
          "html-web-1" "html-db-1" "html-redis-1" "html-celery_worker-1" "html-celery_beat-1"
          "html-migrate-1" "html-collectstatic-1"
          "${ENV}-web-1" "${ENV}-db-1" "${ENV}-redis-1" "${ENV}-celery_worker-1" "${ENV}-celery_beat-1"
          "${ENV}-migrate-1" "${ENV}-collectstatic-1"
        )
        
        # Forzar eliminaci√≥n de contenedores espec√≠ficos comunes
        echo "üîç Eliminando contenedores espec√≠ficos..."
        for container in "${COMMON_CONTAINERS[@]}"; do
          if docker ps -a --format "{{.Names}}" 2>/dev/null | grep -q "^${container}$"; then
            echo "üóëÔ∏è  Eliminando contenedor: $container"
            docker rm -f "$container" 2>/dev/null || true
          fi
        done
        
        # Buscar TODOS los contenedores que empiecen con "html-" o "${ENV}-" y eliminarlos
        echo "üîç Buscando contenedores hu√©rfanos adicionales..."
        ALL_CONTAINERS=$(docker ps -a --format "{{.Names}}" 2>/dev/null || echo "")
        if [ ! -z "$ALL_CONTAINERS" ]; then
          echo "$ALL_CONTAINERS" | while IFS= read -r container; do
            if [ ! -z "$container" ] && ([[ "$container" == "html-"* ]] || [[ "$container" == "${ENV}-"* ]]); then
              echo "üóëÔ∏è  Eliminando contenedor hu√©rfano: $container"
              docker rm -f "$container" 2>/dev/null || true
            fi
          done
        fi
        
        # Limpiar redes hu√©rfanas tambi√©n
        echo "üßπ Limpiando redes hu√©rfanas..."
        docker network prune -f || true
        
        # Esperar un momento m√°s para asegurar que todo est√© limpio
        sleep 2
        
        # Verificar que los contenedores se eliminaron
        echo "‚úÖ Verificaci√≥n: contenedores restantes con prefijo 'html-' o '${ENV}-':"
        REMAINING=$(docker ps -a --format "{{.Names}}" 2>/dev/null | grep -E "^(html-|${ENV}-)" || echo "")
        if [ ! -z "$REMAINING" ]; then
          echo "‚ö†Ô∏è  Advertencia: A√∫n quedan contenedores:"
          echo "$REMAINING"
          echo "üîÑ Intentando eliminarlos nuevamente..."
          echo "$REMAINING" | while IFS= read -r container; do
            docker rm -f "$container" 2>/dev/null || true
          done
        else
          echo "  ‚úÖ Todos los contenedores eliminados correctamente"
        fi
        echo "üî® Construyendo y reiniciando contenedores"
        docker compose build --no-cache
        docker compose up -d
        echo "‚è≥ Esperando a que los servicios est√©n listos..."
        sleep 15
        echo "üîÑ Ejecutando migraciones"
        docker compose run --rm migrate || echo "‚ö†Ô∏è  Advertencia: Error en migraciones"
        echo "üì¶ Recolectando archivos est√°ticos"
        docker compose run --rm collectstatic || echo "‚ö†Ô∏è  Advertencia: Error en collectstatic"
        echo "‚úÖ Despliegue a $ENV completado!"
        if [ "$ENV" == "prod" ]; then
          echo "üåê URL: https://atenea.nxhumans.com"
        else
          echo "üåê URL: https://$ENV.atenea.nxhumans.com"
        fi
        DEPLOY_SCRIPT
