name: Deploy to Server

# Se ejecuta autom√°ticamente cuando:
# - Push a dev ‚Üí despliega a DEV
# - Push a demo ‚Üí despliega a DEMO
# - Push a main ‚Üí despliega a PROD
on:
  push:
    branches: [ dev, demo, main ]

jobs:
  test:
    runs-on: ubuntu-latest
    name: Run Tests
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'
    
    - name: Install system dependencies for Manim
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          pkg-config \
          python3-dev \
          ffmpeg \
          libcairo2-dev \
          libpango1.0-dev \
          libpangocairo-1.0-0 \
          libgirepository1.0-dev \
          gir1.2-pango-1.0
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        
    - name: Run tests
      env:
        SECRET_KEY: ${{ secrets.SECRET_KEY_CI || 'test-secret-key-for-ci' }}
        USE_SQLITE: 'True'
        DEBUG: 'False'
        ALLOWED_HOSTS: 'localhost,127.0.1'
        GCS_BUCKET_NAME: 'test-bucket'
        GCS_PROJECT_ID: 'test-project'
        GOOGLE_APPLICATION_CREDENTIALS: '/tmp/fake-credentials.json'
        HEYGEN_API_KEY: 'test-key'
        GEMINI_API_KEY: 'test-key'
      run: |
        python manage.py test

  deploy:
    needs: test
    runs-on: ubuntu-latest
    name: Deploy to Server
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Determine environment
      id: env
      run: |
        BRANCH="${{ github.ref_name }}"
        if [ "$BRANCH" == "dev" ]; then
          echo "env=dev" >> $GITHUB_OUTPUT
        elif [ "$BRANCH" == "demo" ]; then
          echo "env=demo" >> $GITHUB_OUTPUT
        elif [ "$BRANCH" == "main" ]; then
          echo "env=prod" >> $GITHUB_OUTPUT
        else
          echo "‚ùå Branch desconocido: $BRANCH"
          exit 1
        fi
        echo "‚úÖ Desplegando a: ${{ steps.env.outputs.env }}"
    
    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        # Guardar la clave SSH preservando saltos de l√≠nea correctamente
        # Usar printf para preservar saltos de l√≠nea y caracteres especiales
        printf '%s\n' "${{ secrets.SSH_KEY }}" > ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key
        # Verificar que la clave es v√°lida
        if ! ssh-keygen -l -f ~/.ssh/deploy_key > /dev/null 2>&1; then
          echo "‚ùå Error: La clave SSH no es v√°lida"
          echo "Primeras l√≠neas de la clave:"
          head -3 ~/.ssh/deploy_key
          exit 1
        fi
        echo "‚úÖ Clave SSH v√°lida"
        ssh-keyscan -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true
        chmod 644 ~/.ssh/known_hosts
    
    - name: Prepare deployment files
      run: |
        echo "üìã Verificando docker-compose para ${{ steps.env.outputs.env }}"
        if [ ! -f "docker/docker-compose.${{ steps.env.outputs.env }}.yml" ]; then
          echo "‚ùå Error: No se encontr√≥ docker-compose.${{ steps.env.outputs.env }}.yml"
          exit 1
        fi
        echo "‚úÖ Archivos listos para despliegue"
    
    - name: Deploy to ${{ steps.env.outputs.env }}
      env:
        SSH_KEY: ~/.ssh/deploy_key
        SSH_HOST: ${{ secrets.SSH_HOST }}
        SSH_USER: ${{ secrets.SSH_USERNAME }}
        ENV: ${{ steps.env.outputs.env }}
      run: |
        # ENV_DIR se construye en el servidor, no en el runner
        ENV_DIR_REMOTE="~/$ENV"
        echo "üìÅ Preparando directorio $ENV_DIR_REMOTE en el servidor"
        
        # Crear directorio en el servidor
        ssh -i $SSH_KEY -o StrictHostKeyChecking=no $SSH_USER@$SSH_HOST \
          "mkdir -p $ENV_DIR_REMOTE/html $ENV_DIR_REMOTE/backups" || true
        
        # Preservar credentials.json si existe antes del deploy
        echo "üîê Preservando credentials.json si existe..."
        ssh -i $SSH_KEY -o StrictHostKeyChecking=no $SSH_USER@$SSH_HOST \
          "if [ -f '$ENV_DIR_REMOTE/html/credentials.json' ]; then
            echo 'üìã Guardando credentials.json temporalmente...'
            cp '$ENV_DIR_REMOTE/html/credentials.json' '$ENV_DIR_REMOTE/html/credentials.json.backup' || true
          fi"
        
        # Copiar c√≥digo al servidor usando rsync (excluyendo .git y otros archivos innecesarios)
        echo "üì§ Copiando c√≥digo al servidor..."
        rsync -avz --delete --no-ACL --no-xattrs \
          -e "ssh -i $SSH_KEY -o StrictHostKeyChecking=no" \
          --exclude='.git' \
          --exclude='**/__pycache__/' \
          --exclude='**/__pycache__/**' \
          --exclude='*.pyc' \
          --exclude='*.pyo' \
          --exclude='.env' \
          --exclude='credentials.json' \
          --exclude='venv' \
          --exclude='**/venv/**' \
          --exclude='db.sqlite3' \
          --exclude='.pytest_cache' \
          --exclude='**/.pytest_cache/**' \
          --exclude='node_modules' \
          --exclude='**/node_modules/**' \
          --exclude='.DS_Store' \
          --exclude='**/.DS_Store' \
          --exclude='*.swp' \
          --exclude='*.swo' \
          --exclude='*~' \
          ./ $SSH_USER@$SSH_HOST:$ENV_DIR_REMOTE/html/ || {
          echo "‚ö†Ô∏è  Advertencia: rsync complet√≥ con algunos errores menores"
          echo "üí° Esto puede ser normal si hay archivos temporales o con atributos extendidos"
        }
        
        # Restaurar credentials.json si exist√≠a antes
        echo "üîê Restaurando credentials.json si exist√≠a..."
        ssh -i $SSH_KEY -o StrictHostKeyChecking=no $SSH_USER@$SSH_HOST \
          "if [ -f '$ENV_DIR_REMOTE/html/credentials.json.backup' ]; then
            mv '$ENV_DIR_REMOTE/html/credentials.json.backup' '$ENV_DIR_REMOTE/html/credentials.json'
            echo '‚úÖ credentials.json restaurado'
          else
            echo \"‚ö†Ô∏è  credentials.json no exist√≠a antes, debe crearse manualmente en $ENV_DIR_REMOTE/html/credentials.json\"
          fi"
        
        # Copiar docker-compose al servidor (dentro de html/)
        echo "üìã Copiando docker-compose.yml a html/"
        scp -i $SSH_KEY -o StrictHostKeyChecking=no \
          docker/docker-compose.$ENV.yml \
          $SSH_USER@$SSH_HOST:$ENV_DIR_REMOTE/html/docker-compose.yml
        
        # Ejecutar despliegue en el servidor
        echo "üöÄ Ejecutando despliegue en el servidor"
        ssh -i $SSH_KEY -o StrictHostKeyChecking=no $SSH_USER@$SSH_HOST \
          ENV="$ENV" bash -s << 'DEPLOY_SCRIPT'
        set -e
        ENV_DIR="$HOME/$ENV"
        echo "üìÇ Cambiando a directorio: $ENV_DIR/html"
        cd $ENV_DIR/html || { echo "‚ùå Error: No se encuentra $ENV_DIR/html"; exit 1; }
        
        # Verificar que existe .env
        if [ ! -f ".env" ]; then
          echo "‚ö†Ô∏è  Advertencia: No se encuentra .env en $ENV_DIR/html/.env"
          echo "üí° El archivo .env debe existir en el servidor antes de ejecutar docker compose"
          echo "üí° Puedes crearlo manualmente o copiarlo desde $ENV_DIR/.env si existe"
          if [ -f "$ENV_DIR/.env" ]; then
            echo "üìã Copiando .env desde $ENV_DIR/.env a $ENV_DIR/html/.env"
            cp "$ENV_DIR/.env" "$ENV_DIR/html/.env"
          else
            echo "‚ùå Error: No se encuentra .env en $ENV_DIR/.env ni en $ENV_DIR/html/.env"
            echo "‚ùå El despliegue no puede continuar sin el archivo .env"
            exit 1
          fi
        else
          echo "‚úÖ Archivo .env encontrado en $ENV_DIR/html/.env"
        fi
        
        # Verificar que existe credentials.json (cr√≠tico para GCS)
        if [ ! -f "credentials.json" ]; then
          echo "‚ö†Ô∏è  Advertencia: No se encuentra credentials.json en $ENV_DIR/html/credentials.json"
          echo "üí° El archivo credentials.json debe existir en el servidor para que GCS funcione"
          echo "üí° Puedes crearlo manualmente o copiarlo desde $ENV_DIR/credentials.json si existe"
          if [ -f "$ENV_DIR/credentials.json" ]; then
            echo "üìã Copiando credentials.json desde $ENV_DIR/credentials.json a $ENV_DIR/html/credentials.json"
            cp "$ENV_DIR/credentials.json" "$ENV_DIR/html/credentials.json"
            echo "‚úÖ credentials.json copiado desde $ENV_DIR/"
          else
            echo "‚ùå Error: No se encuentra credentials.json en $ENV_DIR/credentials.json ni en $ENV_DIR/html/credentials.json"
            echo "‚ùå El despliegue puede continuar pero GCS no funcionar√° sin credentials.json"
            echo "üí° Crea el archivo manualmente en $ENV_DIR/html/credentials.json antes de usar GCS"
          fi
        else
          echo "‚úÖ Archivo credentials.json encontrado en $ENV_DIR/html/credentials.json"
        fi
        
        # Verificar que POSTGRES_PASSWORD est√° definido en .env
        echo "üîç Verificando variables cr√≠ticas en .env..."
        if grep -q "^POSTGRES_PASSWORD=" .env 2>/dev/null; then
          echo "‚úÖ POSTGRES_PASSWORD encontrado en .env"
        else
          echo "‚ö†Ô∏è  POSTGRES_PASSWORD no est√° definido en .env"
          echo "üîë Generando contrase√±a autom√°ticamente..."
          # Generar contrase√±a segura (25 caracteres alfanum√©ricos)
          POSTGRES_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-25)
          echo "" >> .env
          echo "# PostgreSQL password (generado autom√°ticamente)" >> .env
          echo "POSTGRES_PASSWORD=$POSTGRES_PASSWORD" >> .env
          echo "‚úÖ POSTGRES_PASSWORD generado y agregado al .env"
          echo "‚ö†Ô∏è  IMPORTANTE: Guarda esta contrase√±a en un lugar seguro"
          echo "üîë POSTGRES_PASSWORD=$POSTGRES_PASSWORD"
          echo "üí° Si ya existe una base de datos con otra contrase√±a, actualiza manualmente el .env"
        fi
        
        # Mostrar informaci√≥n del .env (sin mostrar valores sensibles)
        echo "üìã Variables definidas en .env (primeras 10):"
        grep -E "^[A-Z_]+=" .env | sed 's/=.*/=***/' | head -10 || echo "‚ö†Ô∏è  No se pudieron leer las variables del .env"
        
        echo "üõë Deteniendo y eliminando contenedores existentes"
        
        # Primero, detener todos los contenedores que puedan estar corriendo
        echo "‚è∏Ô∏è  Deteniendo contenedores con docker compose..."
        docker compose stop || true
        
        # Esperar un momento para que los contenedores se detengan completamente
        sleep 2
        
        # Eliminar contenedores con docker compose down
        echo "üóëÔ∏è  Eliminando contenedores con docker compose down..."
        docker compose down --remove-orphans -v || true
        
        # Eliminar contenedores que puedan estar detenidos pero a√∫n existan
        docker compose rm -f || true
        
        # Obtener lista de contenedores que empiecen con "html-" o "${ENV}-" y eliminarlos
        echo "üîç Buscando y eliminando contenedores con prefijo 'html-' o '${ENV}-'..."
        
        # Crear array temporal con IDs de contenedores a eliminar
        CONTAINER_IDS=$(docker ps -a --format "{{.ID}} {{.Names}}" 2>/dev/null | grep -E "(html-|${ENV}-)" | awk '{print $1}' || echo "")
        
        if [ ! -z "$CONTAINER_IDS" ]; then
          echo "üìã Contenedores encontrados para eliminar:"
          docker ps -a --format "{{.ID}} {{.Names}}" 2>/dev/null | grep -E "(html-|${ENV}-)" || true
          
          # Eliminar cada contenedor por ID
          for container_id in $CONTAINER_IDS; do
            if [ ! -z "$container_id" ]; then
              echo "üóëÔ∏è  Eliminando contenedor ID: $container_id"
              docker stop "$container_id" 2>/dev/null || true
              docker rm -f "$container_id" 2>/dev/null || true
            fi
          done
        fi
        
        # Tambi√©n intentar eliminar por nombres espec√≠ficos comunes
        echo "üîç Eliminando contenedores por nombres espec√≠ficos..."
        for name in "html-web-1" "html-db-1" "html-redis-1" "html-celery_worker-1" "html-celery_beat-1" \
                    "html-migrate-1" "html-collectstatic-1" \
                    "${ENV}-web-1" "${ENV}-db-1" "${ENV}-redis-1" "${ENV}-celery_worker-1" "${ENV}-celery_beat-1" \
                    "${ENV}-migrate-1" "${ENV}-collectstatic-1"; do
          CONTAINER_ID=$(docker ps -a --filter "name=^${name}$" --format "{{.ID}}" 2>/dev/null | head -1)
          if [ ! -z "$CONTAINER_ID" ]; then
            echo "üóëÔ∏è  Eliminando contenedor por nombre: $name (ID: $CONTAINER_ID)"
            docker stop "$CONTAINER_ID" 2>/dev/null || true
            docker rm -f "$CONTAINER_ID" 2>/dev/null || true
          fi
        done
        
        # Limpiar redes hu√©rfanas tambi√©n
        echo "üßπ Limpiando redes hu√©rfanas..."
        docker network prune -f || true
        
        # Esperar un momento m√°s para asegurar que todo est√© limpio
        sleep 3
        
        # Verificaci√≥n final antes de continuar
        FINAL_CHECK=$(docker ps -a --format "{{.Names}}" 2>/dev/null | grep -E "(html-|${ENV}-)" || echo "")
        if [ ! -z "$FINAL_CHECK" ]; then
          echo "‚ö†Ô∏è  Advertencia: A√∫n quedan contenedores despu√©s de la limpieza:"
          echo "$FINAL_CHECK"
          echo "üîÑ Intentando eliminaci√≥n forzada final por ID..."
          FINAL_IDS=$(docker ps -a --format "{{.ID}} {{.Names}}" 2>/dev/null | grep -E "(html-|${ENV}-)" | awk '{print $1}' || echo "")
          for container_id in $FINAL_IDS; do
            if [ ! -z "$container_id" ]; then
              echo "üóëÔ∏è  Forzando eliminaci√≥n de contenedor ID: $container_id"
              docker stop "$container_id" 2>/dev/null || true
              docker rm -f "$container_id" 2>/dev/null || true
            fi
          done
        else
          echo "  ‚úÖ Todos los contenedores eliminados correctamente"
        fi
        echo "üî® Construyendo y reiniciando contenedores"
        docker compose build --no-cache
        docker compose up -d
        echo "‚è≥ Esperando a que los servicios est√©n listos..."
        sleep 15
        echo "üîÑ Ejecutando migraciones"
        docker compose run --rm migrate || echo "‚ö†Ô∏è  Advertencia: Error en migraciones"
        echo "üì¶ Recolectando archivos est√°ticos"
        docker compose run --rm collectstatic || echo "‚ö†Ô∏è  Advertencia: Error en collectstatic"
        echo "‚úÖ Despliegue a $ENV completado!"
        if [ "$ENV" == "prod" ]; then
          echo "üåê URL: https://atenea.nxhumans.com"
        else
          echo "üåê URL: https://$ENV.atenea.nxhumans.com"
        fi
        DEPLOY_SCRIPT
